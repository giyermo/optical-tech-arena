import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('service.py', b'from edge import Edge\nfrom node import Node\n\nclass Service:\n    def __init__(self, id, src, dst):\n        self.id = id  # Unique identifier for the service\n        self.src = src  # Source node\n        self.dst = dst  # Destination node\n        self.path = []  # List of edge IDs in the service path\n        self.wavelengths = []  # List of tuples (start, end) for each edge in the path\n        self.active = True  # Indicates if the service is active\n        self.dead = False  # Indicates if the service is marked as dead\n        self.value = 10000  # Value attribute with upper limit\n\n    def add_edge(self, edge_id, wavelength_range):\n        """Add an edge ID and its corresponding wavelength range to the service."""\n        self.path.append(edge_id)  # Add the edge ID to the path\n        self.wavelengths.append(wavelength_range)  # Add the wavelength range\n\n    def deactivate(self):\n        """Deactivate the service."""\n        self.active = False\n\n    def mark_as_dead(self):\n        """Mark the service as dead."""\n        self.dead = True\n\n    def __repr__(self):\n        return (f"Service(id={self.id}, src={self.src}, dst={self.dst}, "\n                f"path={self.path}, wavelengths={self.wavelengths}, "\n                f"active={self.active}, dead={self.dead}, value={self.value})")\n\n# # Create sample edges\n# edge1 = Edge(id=1, node1=1, node2=2)\n# edge2 = Edge(id=2, node1=2, node2=3)\n# edge3 = Edge(id=3, node1=3, node2=4)\n\n# # Create a service\n# service1 = Service(id=1, src=1, dst=4)\n\n# # Add edge IDs to the service with corresponding wavelength ranges\n# service1.add_edge(edge_id=1, wavelength_range=(10, 15))\n# service1.add_edge(edge_id=2, wavelength_range=(20, 25))\n# service1.add_edge(edge_id=3, wavelength_range=(30, 35))\n\n# # Display the service state\n# print("Initial service state:")\n# print(service1)\n\n# # Deactivate the service\n# service1.deactivate()\n\n# # Mark the service as dead\n# service1.mark_as_dead()\n\n# # Display the service state after changes\n# print("\\nService state after deactivation and marking as dead:")\n# print(service1)\n')
    __stickytape_write_module('edge.py', b'class Edge:\n    def __init__(self, id, node1, node2):\n        self.id = id  # Edge identifier\n        self.nodes = (node1, node2)  # Tuple of nodes that this edge connects\n        self.services = {}  # Dictionary of services {service_id: (start_wavelength, end_wavelength)}\n        self.active = True  # Edge active status, initially set to active\n\n    def add_service(self, service_id, wavelength_range):\n        """Add a service to the edge with the specified wavelength range."""\n        start, end = wavelength_range\n\n        # Validate the range to ensure it falls between 1 and 40\n        if 1 <= start <= 40 and 1 <= end <= 40 and start <= end:\n            self.services[service_id] = (start, end)\n        else:\n            raise ValueError("Wavelength range must be between 1 and 40.")\n\n    def remove_service(self, service_id):\n        """Remove a service from the edge."""\n        if service_id in self.services:\n            del self.services[service_id]\n\n    def deactivate(self):\n        """Deactivate the edge. Once deactivated, it cannot be activated again."""\n        if self.active:  # Only deactivate if it is currently active\n            self.active = False\n        # Return the list of services that were associated with this edge\n        associated_services = list(self.services.keys())\n        return associated_services\n\n    def has_available_wavelengths(self, start, end):\n        """Check if there are available wavelengths in the edge for the given range."""\n        # Check for overlap with existing services\n        for existing_service_id, (existing_start, existing_end) in self.services.items():\n            # Check for overlap\n            if (start <= existing_end and end >= existing_start):\n                return False  # There is a collision in wavelength ranges\n        return True  # No collisions found, wavelengths are available\n\n    def __repr__(self):\n        return (f"Edge(id={self.id}, nodes={self.nodes}, "\n                f"services={self.services}, active={self.active})")\n\n')
    __stickytape_write_module('node.py', b'class Node:\n    def __init__(self, id, opportunities):\n        self.id = id  # Node identifier\n        self.opps = opportunities  # Number of conversion opportunities\n        self.adj = {}  # Dictionary for adjacent nodes and lists of edge IDs\n\n    def add_adj(self, node, edge_id):\n        # Add an edge ID to the list for the given adjacent node ID\n        if node.id in self.adj:\n            self.adj[node.id].append(edge_id)  # Append to the existing list of edge IDs\n        else:\n            self.adj[node.id] = [edge_id]  # Create a new list if this is the first edge\n\n    def remove_adj(self, node, edge_id):\n        # Remove the specified edge ID to the adjacent node ID\n        if node.id in self.adj:\n            if edge_id in self.adj[node.id]:\n                self.adj[node.id].remove(edge_id)  # Remove the specific edge ID\n                if not self.adj[node.id]:  # If no more edges remain, remove the entry\n                    del self.adj[node.id]\n\n    def get_adj(self):\n        # Return the list of adjacent node IDs\n        return list(self.adj.keys())\n\n    def get_edges(self, node):\n        # Return the list of edge IDs to a specific adjacent node ID\n        return self.adj.get(node.id, [])\n\n    def __repr__(self):\n        # Return a string representation of the node\n        return (f"Node(id={self.id}, "\n                f"opps={self.opps}, "\n                f"adj={self.adj})")\n\n# # Create some nodes\n# node1 = Node(1, 10)\n# node2 = Node(2, 5)\n# node3 = Node(3, 7)\n\n# # Add edges between nodes (using numeric edge IDs)\n# node1.add_adj(node2, 1)  # Edge ID 1 connects node1 to node2\n# node1.add_adj(node2, 2)  # Edge ID 2 (parallel edge) connects node1 to node2\n# node1.add_adj(node3, 3)  # Edge ID 3 connects node1 to node3\n# node2.add_adj(node3, 4)  # Edge ID 4 connects node2 to node3\n\n# # Display the nodes and their connections\n# print("Nodes and their connections before removal:")\n# print(node1)\n# print(node2)\n# print(node3)\n\n# # Remove an edge\n# node1.remove_adj(node2, 1)  # Remove edge ID 1 connecting node1 to node2\n# node1.remove_adj(node2, 2)  # Remove edge ID 1 connecting node1 to node2\n\n# # Display the updated nodes\n# print("\\nAfter removing edge ID 1:")\n# print(node1)\n# print(node2)\n# print(node3)\n\n# # Remove the last edge between node1 and node2\n# node1.remove_adj(node2, 102)  # Remove edge ID 102 connecting node1 to node2\n\n# # Display the updated nodes\n# print("\\nAfter removing edge ID 102 (last edge):")\n# print(node1)\n# print(node2)\n')
    __stickytape_write_module('scenario_parser.py', b'import enum\n\ndef parse_network():\n    """\n    Parse the input data for the graph and services.\n\n    It reads the input data from the standard input, parses it and returns the graph and services as a tuple.\n\n    The input data is divided into four parts: The size of the graph, the nodes, the edges and the services.\n    The size of the graph contains the number of nodes and edges.\n    The nodes are given as a list of channel conversion opportunities.\n    The edges are given as a list of pairs of nodes.\n    The services are given as a list of tuples, containing the source, destination, number of edges, wavelength start, wavelength end and value of the service.\n    The path of each service is given as a list of edges.\n\n    Returns:\n        tuple: A tuple containing the nodes, edges and services of the graph.\n    """\n\n    class Kind(enum.Enum):\n        #Como el input est\xc3\xa1 dividido por partes, enum ayuda a dividirlo\n        SIZE = 0\n        NODES = 1\n        EDGES = 2\n        SERVICES_NO = 3\n        SERVICES = 4\n        END = 5\n\n    kind = Kind.SIZE\n    nodes = [] \n    edges_read = 0 #num de lineas de edges le\xc3\xaddas\n    edges = []\n    services_read = 0 #num de lineas de services le\xc3\xaddas\n    services = []\n\n    while kind != Kind.END:\n        # Set the network (graph) properties during iterations\n        l = input()\n        if kind == Kind.SIZE:\n            #Set the size of the network (graph)\n            kind = Kind.NODES # Move to nodes\n            nodes_no, edges_no = [int(x) for x in l.split()]\n        elif kind == Kind.NODES:\n            #Set the list of nodes and it\'s channel conversion oportunities\n            kind = Kind.EDGES # Move to edges\n            nodes = list(int(x) for x in l.split())\n        elif kind == Kind.EDGES:\n            # For each iteration, add a edge to the network (graph)\n            edges_read += 1\n            if edges_read == edges_no:\n                kind = Kind.SERVICES_NO\n            edge = list(int(x) for x in l.split())\n            edges.append(edge)\n        elif kind == Kind.SERVICES_NO:\n            #Set the number of services in the network\n            kind = Kind.SERVICES\n            services_no = int(l)\n        elif kind == Kind.SERVICES:\n            # Add a service to the network (graph)\n            services_read += 1\n            if services_read == services_no:\n                kind = Kind.END\n\n            # Parse the service\n            service = list(int(x) for x in l.split())\n\n            # Parse the service edges\n            l = input()\n            service.append(list(int(x) for x in l.split()))\n\n            # Add the service to the network\n            services.append(service)\n\n    return nodes, edges, services')
    __stickytape_write_module('scenario_maker.py', b'import random\n\ndef produce_scenarios(edges):\n    """\n    Produce failure scenarios\n\n    Naive version, with random failures\n\n    Parameters\n    ----------\n    edges : list\n        List of edges of the graph\n\n    Returns\n    -------\n    list\n        List of lists of edges that fail in each scenario\n    """\n    scenarios_no = 1# random.randint(1, T_1_MAX)\n    scenarios = []\n    for scenario in range(scenarios_no):\n        scenario_edges = []\n        failures = 1#random.randint(1, min(int(len(edges)/3), T_2_MAX))\n        for _ in range(failures):\n            edge = random.randint(1, len(edges))\n            if edge not in scenario_edges:\n                scenario_edges.append(edge)\n        if scenario_edges not in scenarios:\n            scenarios.append(scenario_edges)\n    return scenarios\n\ndef print_scenarios(scenarios:list):\n    """\n    Print failure scenarios to the standard output\n\n    The first line contains the number of failure scenarios.\n    The following lines describe each scenario, with the first number being\n    the number of edges that fail, and the following numbers the indices of\n    the edges that fail, counted from 1.\n    """\n    print(len(scenarios), flush=True)\n    for scenario in scenarios:\n        print(len(scenario), flush=True)\n        # Edges should be counted from 1\n        print(*[edge for edge in scenario], flush=True)')
    __stickytape_write_module('network.py', b'from node import Node\nfrom edge import Edge\nfrom service import Service\nfrom collections import deque\n\nclass Network:\n    def __init__(self, node_list, edge_list, service_list):\n        self.nodes = {}  # Dictionary of nodes {node_id: Node}\n        self.edges = {}  # Dictionary of edges {edge_id: Edge}\n        self.services = {}  # Dictionary of services {service_id: Service}\n\n        # Initialize the network with given nodes, edges, and services\n        self._initialize_nodes(node_list)\n        self._initialize_edges(edge_list)\n        self._initialize_services(service_list)\n\n    def _initialize_nodes(self, node_list):\n        """Initialize nodes with channel conversion opportunities."""\n        for idx, conversion_opportunities in enumerate(node_list, start=1):\n            self.nodes[idx] = Node(idx, conversion_opportunities)\n\n    def _initialize_edges(self, edge_list):\n        """Initialize edges with pairs of connected nodes."""\n        for idx, (node1, node2) in enumerate(edge_list, start=1):\n            self.add_edge(idx, node1, node2)\n\n    def _initialize_services(self, service_list):\n        """Initialize services based on the given list format."""\n        for service_id, (src, dst, num_edges, start_wl, end_wl, value, path) in enumerate(service_list, start=1):\n            self.add_service(service_id, src, dst, path, (start_wl, end_wl), value)\n\n    def add_edge(self, edge_id, node1, node2):\n        """Add an edge to the network, connecting two nodes."""\n        if edge_id not in self.edges:\n            # Add nodes if they don\'t exist\n            if node1 not in self.nodes:\n                self.nodes[node1] = Node(node1, 0)  # Create node if it doesn\'t exist\n            if node2 not in self.nodes:\n                self.nodes[node2] = Node(node2, 0)  # Create node if it doesn\'t exist\n\n            # Create the new edge\n            edge = Edge(edge_id, node1, node2)\n            self.edges[edge_id] = edge\n            \n            # Update adjacency lists in nodes\n            self.nodes[node1].add_adj(self.nodes[node2], edge_id)\n            self.nodes[node2].add_adj(self.nodes[node1], edge_id)\n        else:\n            raise ValueError(f"Edge {edge_id} already exists.")\n\n    def add_service(self, service_id, src, dst, path, wavelength_range, value):\n        """Add a service to the network, specifying source, destination, path, wavelength, and value."""\n        if service_id not in self.services:\n            if all(edge_id in self.edges for edge_id in path):\n                # Create the service and add it to the network\n                service = Service(service_id, src, dst)\n                for edge_id in path:\n                    service.add_edge(edge_id, wavelength_range)  # Add edge and wavelength to service\n                    self.edges[edge_id].add_service(service_id, wavelength_range)  # Register service with edge\n\n                # Cap the service value at 100,000\n                service.value = min(value, 100000)\n                self.services[service_id] = service\n            else:\n                raise ValueError("Invalid path. Some edges in the path do not exist in the network.")\n        else:\n            raise ValueError(f"Service {service_id} already exists.")\n\n    def deactivate_edge(self, edge_id):\n        """Deactivate an edge and mark all services passing through it as inactive, returning their IDs."""\n        if edge_id in self.edges:\n            edge = self.edges[edge_id]\n            if edge.active:\n                # Deactivate the edge\n                associated_services = edge.deactivate()  # Get associated services and deactivate the edge\n                deactivated_service_ids = []  # List to hold IDs of deactivated services\n\n                # Mark all services using this edge as deactivated\n                for service_id in associated_services:\n                    if service_id in self.services:\n                        service = self.services[service_id]\n                        if not service.dead:  # Check if the service is not dead\n                            service.deactivate()  # Mark service as inactive\n                            deactivated_service_ids.append(service_id)  # Add service ID to the list\n\n                return deactivated_service_ids\n            else:\n                raise ValueError(f"Edge {edge_id} is already deactivated.")\n        else:\n            raise ValueError(f"Edge {edge_id} does not exist in the network.")\n\n\n    def remove_service_from_edges(self, service_id):\n        """Remove the specified service from all edges in its path without clearing the path."""\n        if service_id not in self.services:\n            raise ValueError(f"Service ID {service_id} does not exist in the network.")\n\n        service = self.services[service_id]\n        edge_ids = service.path  # Get the list of edge IDs in the service path\n\n        for edge_id in edge_ids:\n            if edge_id in self.edges:\n                edge = self.edges[edge_id]\n                edge.remove_service(service_id)  # Remove the service from the edge\n            else:\n                raise ValueError(f"Edge ID {edge_id} does not exist in the network.")\n\n\n    def redirect_service(self, service):\n        """Attempt to redirect a service to a new path, checking for available wavelengths."""\n        src = service.src\n        dst = service.dst\n\n        # Initialize BFS queue and visited set\n        queue = deque([(src, [])])  # Start from the source node\n        visited = set()  # Keep track of visited nodes\n\n        while queue:\n            current_node, path = queue.popleft()\n\n            # If we\'ve reached the destination\n            if current_node == dst:\n                return path  # Return the new path\n\n            if current_node in visited:\n                continue\n\n            visited.add(current_node)\n\n            # Get adjacent edges from the current node\n            current_adj_nodes = self.nodes[current_node].get_adj()\n            for adj_node_id in current_adj_nodes:\n                edges_to_adj = self.nodes[current_node].get_edges(self.nodes[adj_node_id])\n                for edge_id in edges_to_adj:\n                    edge = self.edges[edge_id]\n                    \n                    # Check if the edge is active and has available wavelengths\n                    if edge.active:\n                        for (start, end) in service.wavelengths:  # Assuming service.wavelengths is a list of tuples\n                            if edge.has_available_wavelengths(start, end):\n                                # Append the edge ID to the path and enqueue the adjacent node\n                                queue.append((adj_node_id, path + [edge_id]))\n                                break  # Move to the next edge since we found an available wavelength\n\n        return None  # Failed to redirect the service\n\n\n    def __repr__(self):\n        return (f"Network(nodes={list(self.nodes.keys())}, "\n                f"edges={list(self.edges.keys())}, "\n                f"services={list(self.services.keys())})")\n\n\n')
    __stickytape_write_module('functions.py', b'def process_scenario(network, edge_ids):\n    """\n    Deactivate edges, mark associated services as inactive, \n    and attempt to redirect the services.\n\n    :param network: The Network object containing edges and services.\n    :param edge_ids: A list of edge IDs to deactivate.\n    :return: A tuple containing:\n             - A list of service IDs that were successfully redirected.\n             - The updated network.\n    """\n    redirected_services = []  # List to collect IDs of successfully redirected services\n    deactivated_services = []  # List to collect all deactivated service IDs\n\n    for edge_id in edge_ids:\n        # Deactivate the edge and mark associated services as inactive\n        try:\n            # Deactivate the edge and get the associated services that were deactivated\n            deactivated_services.extend(network.deactivate_edge(edge_id))  # Use .extend() for better performance\n        except ValueError as e:\n            # Raise an exception if the edge does not exist\n            raise ValueError(f"Error: {e}")\n\n    # After processing all edges, attempt to redirect the deactivated services\n    for service_id in deactivated_services:\n        service = network.services.get(service_id)\n        # Check if the service is not dead and not active\n        if service and not service.dead and not service.active:  \n            # Attempt to redirect the service\n            redirection = network.redirect_service(service)\n            if redirection:  # Redirect the service\n                network.remove_service_from_edges(service_id)  # Remove the service from edges\n                network.services[service_id].path = redirection\n                wavelength = network.services[service_id].wavelengths[0]\n                for edge in redirection:\n                    network.edges[edge].services[service_id] = wavelength\n                network.services[service_id].wavelengths = [wavelength]*len(redirection)  # Mark service as active\n                redirected_services.append(service_id)  # Add to redirected list\n            else:\n                service.mark_as_dead()  # Mark service as dead if redirection fails\n\n    return redirected_services, network  # Return the list of redirected services and the updated network\n')
    #!/usr/bin/env python3
    from service import Service
    from scenario_parser import *
    from scenario_maker import *
    from network import Network
    from functions import *
    import copy
    
    nodes, edges, services = parse_network()
    base_network = Network(nodes, edges, services)
    
    # scenarios = produce_scenarios(edges)
    # print_scenarios(scenarios)
    
    print("1", flush=True)
    print("1", flush=True)
    print("1", flush=True)
    
    
    n_scenarios = int(input())
    
    
    for _ in range(n_scenarios):
        scenario = copy.deepcopy(base_network)
    
        continuee = True
    
        while continuee:
            line = input()
    
            if line == "-1":
                continuee = False
            else:
                edges_ids = [int(x) for x in line.split()]
    
                redirected_services, scenario = process_scenario(scenario, edges_ids)
    
                print(len(redirected_services), flush=True)
                for service in redirected_services:
                    print(service, len(scenario.services[service].path), flush=True)
                    path = scenario.services[service].path
                    wavelengths = scenario.services[service].wavelengths
                    stuff = []
                    for edge, (w_start, w_end) in zip(path, wavelengths):
                        stuff.extend([edge, w_start, w_end])
    
                    print(*stuff, flush=True)
    